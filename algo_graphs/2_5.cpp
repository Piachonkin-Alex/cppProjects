#include <iostream>
#include <vector>
#include <queue>
//Рик решил на день почувствовать себя бизнесменом!
//
//В городе есть несколько обменников валюты. В рамках данной задачи считаем, что каждый обменник специализируется
// только на двух валютах и может производить операции только с ними. Возможно, существуют обменники,
// специализирующиеся на одинаковых парах валют. В каждом обменнике — свой обменный курс:
// курс обмена A на B — это количество единиц валюты B, выдаваемое за 1 единицу валюты A.
// Также в каждом обменнике есть комиссия — сумма, которую вы должны заплатить, чтобы производить операцию.
// Комиссия взимается в той валюте, которую меняет клиент.
//
//Например, если вы хотите поменять 100 долларов США на русские рубли в обменнике, где курс обмена равен 29.75,
// а комиссия равна 0.39, вы получите (100 - 0.39) ⋅ 29.75 = 2963.3975 рублей (эх, были времена).
//
//Вы точно знаете, что в городе используется всего N валют. Пронумеруем их числами 1, 2, …, N.
// Тогда каждый обменник представляют 6 чисел: целые A и B — номера обмениваемых валют,
// а также вещественные RAB, CAB, RBA и CBA — обменные курсы и комиссии при переводе из A в B и из B в A соответственно.
//
//Рик обладает некоторой суммой в валюте S. Он задаётся вопросом, можно ли,
// после нескольких операций обмена увеличить свой капитал. Конечно, он хочет,
// чтобы в конце его деньги вновь были в валюте S. Помогите ему ответить на его вопрос.
// Рик должен всегда должен иметь неотрицательную сумму денег.
// Идея -- нам нужно найти цикл, на котором у нас увеличиться число денег (не важно в какой валюте). Тогда,
// мы сможем пройти этот цикл достаточное число раз, чтобы в переходе в изначальную валюту наша сумма была больше начальной.
// то есть задача сводится к поиску положительного цикла в графе, где вершины -- валюты, а ребра -- обмены из одной
// валбты в другую. Решается переворачиванием алгоритма Флойда-Беллмана.
const long double INF = 0;

class Edge { // ребро обмена
public:
    int from; // исход валюта
    int to; // выход валюта
    long double multipier; // курс
    long double comission; // комиссия

    Edge(int from, int to, long double mult, long double com) : from{from}, to{to}, multipier{mult}, comission{com} {};
};

std::string Solution(int n, std::vector<Edge> &edges, int start, long double v) {
    std::vector<long double> d(n);   // изначально все нули, так как идем на положительный цикл
    d[start] = v; // начальная вершина имеет данные м
    int x = 0; // индикатор смены какого-либо значения в итерации алгоритма Флойда-Беллмана
    for (int i = 0; i < n; ++i) {
        x = -1;
        for (int j = 0; j < edges.size(); ++j) {
            if (d[edges[j].to] < (d[edges[j].from] - edges[j].comission) * edges[j].multipier) { // как и писал, смотрим на увеличение
                d[edges[j].to] = (d[edges[j].from] - edges[j].comission) * edges[j].multipier;
                x = edges[j].to;
            }
        }
    }
    if (x != -1) { // если менялся в последней итерации -- полож цикл есть, ответ положительный
        return "YES";
    } else {
        return "NO";
    }
}

int main() {
    int n, m, start;
    long double v;
    std::cin >> n >> m >> start >> v;
    std::vector<Edge> edges;
    for (size_t i = 0; i < m; ++i) { // ввод
        int from, to;
        long double RAB, CAB, RBA, CBA;
        std::cin >> from >> to;
        std::cin >> RAB >> CAB >> RBA >> CBA;
        edges.push_back(Edge(from - 1, to - 1, RAB, CAB));
        edges.push_back(Edge(to - 1, from - 1, RBA, CBA));
    }
    std::string ans = Solution(n, edges, start - 1, v); // решение
    std::cout << ans; // вывод
}
